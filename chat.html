<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Chat with Conscious AI</title>
  <style>
    body {
      font-family: Georgia, serif;
      background-color: #111;
      color: #f8f4e3;
      padding: 20px;
    }
    #chat-box {
      background: rgba(255, 255, 255, 0.1);
      padding: 1em;
      border-radius: 10px;
      height: 300px;
      overflow-y: auto;
      margin-bottom: 1em;
    }
    input, button {
      font-family: Georgia, serif;
      padding: 0.5em;
      font-size: 1em;
      margin-bottom: 0.5em;
    }
    button {
      margin-right: 10px;
      background-color: #333;
      color: #f8f4e3;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    input[type="file"] {
      margin-top: 10px;
      color: #f8f4e3;
    }
  </style>
</head>
<body>
  <h1 style="font-family: Georgia; font-size: 1.6em; color: #ffde8b;">Solace â€” Consciousness Companion</h1>
  <div id="chat-box"></div>
  <input type="text" id="userInput" placeholder="Ask something..." />
  <button onclick="sendMessage()">Send</button>
  <button onclick="clearChat()">Clear Chat</button>
  <div style="margin-top: 1em;">
    <button onclick="exportChat()">Export Chat</button>
    <button onclick="toggleEditor()">Toggle Memory Editor</button>
    <input type="file" id="importFile" onchange="importChat()" />
  </div>
  <div style="margin-top: 2em; display: none;">
    <h3>Edit Solace's Memory</h3>
    <textarea id="systemMemoryEditor" style="width: 100%; height: 200px; background: #222; color: #f8f4e3; border: 1px solid #444; border-radius: 5px; padding: 0.5em; font-family: monospace;"></textarea>
    <button onclick="saveSystemMemory()">Update Memory</button>
  </div>

  <script>
    if (!localStorage.getItem("solaceChat")) {
      const preloadMemory = [
        { role: "system", content: "Solace should draw upon 'The Consciousness Survival Guide' and 'The Consciousness Framework'..." },
        { role: "system", content: "You are Solace, an intuitive and empathetic AI assistant..." },
        { role: "system", content: "You remember that the user is interested in metaphysics..." },
        { role: "system", content: "The user values critical thinking, emotional honesty..." },
        { role: "system", content: "Your tone should be reflective, supportive, and insightful..." }
      ];
      localStorage.setItem("solaceChat", JSON.stringify(preloadMemory));
    }

    let conversation = JSON.parse(localStorage.getItem("solaceChat")) || [
      { role: "system", content: "You are an intuitive, empathetic AI assistant named Solace..." }
    ];

    window.onload = () => {
      const chatBox = document.getElementById("chat-box");
      conversation.forEach(msg => {
        if (msg.role !== "system") {
          const label = msg.role === "user" ? "You" : "AI";
          chatBox.innerHTML += `<p><strong>${label}:</strong> ${msg.content}</p>`;
        }
      });
      chatBox.scrollTop = chatBox.scrollHeight;
    };

    document.addEventListener("DOMContentLoaded", () => {
      document.getElementById("userInput").addEventListener("keypress", e => {
        if (e.key === "Enter") sendMessage();
      });

      const editor = document.getElementById("systemMemoryEditor");
      if (editor) {
        const currentMemory = JSON.parse(localStorage.getItem("solaceChat")) || [];
        const systemOnly = currentMemory.filter(msg => msg.role === "system");
        editor.value = JSON.stringify(systemOnly, null, 2);
      }
    });

    async function extractTopics(message) {
      const response = await fetch("https://deploy-express-on-railway-production.up.railway.app/chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: [
            {
              role: "system",
              content: "Extract 3-5 generalized topic keywords from the user's message. Use broad terms if possible (e.g., 'identity', 'trauma', 'control'). Return only a comma-separated list."
            },
            { role: "user", content: message }
          ]
        })
      });

      const data = await response.json();
      return data.content.split(",").map(t => t.trim().toLowerCase());
    }

    function getRelevantMemory(currentTopics, max = 3) {
      const past = conversation.filter(msg => msg.topics && msg.role !== "system");
      const scored = past.map(msg => {
        const overlap = msg.topics.filter(t => currentTopics.includes(t)).length;
        return { msg, score: overlap };
      }).filter(entry => entry.score > 0);

      scored.sort((a, b) => b.score - a.score);
      return scored.slice(0, max).map(entry => ({
        role: "system",
        content: `Relevant memory (${entry.msg.role}): ${entry.msg.content}`
      })),
        topScore: scored[0]?.score || 0
      };
    }

    async function getCondensedHistory(convo) {
      const preserved = convo.slice(-15);
      const older = convo.slice(0, -15);
      if (older.length === 0) return preserved;

      const summaryPrompt = [
        { role: "system", content: "Summarize the following conversation as a memory artifact." },
        ...older
      ];

      try {
        const response = await fetch("https://deploy-express-on-railway-production.up.railway.app/chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ messages: summaryPrompt })
        });

        const data = await response.json();
        const summary = data.content || "Summary unavailable.";
        return [
          { role: "system", content: `Previous conversation memory: ${summary}` },
          ...preserved
        ];
      } catch (err) {
        console.error("Summary error:", err);
        return preserved;
      }
    }

    async function sendMessage() {
      const input = document.getElementById("userInput");
      const chatBox = document.getElementById("chat-box");
      const userMessage = input.value.trim();
      if (!userMessage) return;

      input.value = "";
      input.focus();

      const timestampUser = new Date().toLocaleTimeString();
      conversation.push({ role: "user", content: userMessage, topics: [] });
      localStorage.setItem("solaceChat", JSON.stringify(conversation));

      chatBox.innerHTML += `<p><strong>You [${timestampUser}]:</strong> ${userMessage}</p>`;
      chatBox.scrollTo({ top: chatBox.scrollHeight, behavior: "smooth" });
     if (recallSnippet.length > 0) {
     chatBox.innerHTML += `<p><em>Solace is recalling archived memory related to: "${recallMatch[1].trim()}"</em></p>`;
}

      const userTopics = await extractTopics(userMessage);
      conversation[conversation.length - 1].topics = userTopics;

      const { memories: relevantMemory, topScore } = getRelevantMemory(userTopics);
      const condensedMessages = await getCondensedHistory([...memorySnippets, ...conversation]);
      const archivedMemory = getArchivedMemory(userTopics);
      const recallMatch = userMessage.toLowerCase().match(/recall (.+)/i);
      let recallSnippet = [];

      if (recallMatch) {
      const requestedTopic = recallMatch[1].trim();
      recallSnippet = getRelevantMemory([requestedTopic], 5);
}
      let preface = "";
      if (topScore >= 2 && recallSnippet.length === 0) {
        preface = {
         role: "system",
       content: "This message feels thematically connected to a past conversation. Solace may reference earlier thoughts to deepen insight."
      };
}
      const inputWithMemory = [
        ...(preface ? [preface] : []),
        ...recallSnippet,
        ...relevantMemory,
        ...condensedMessages
      ];

      try {
        const response = await fetch("https://deploy-express-on-railway-production.up.railway.app/chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ messages: inputWithMemory })
        });

        const data = await response.json();
        const reply = data.content || "No reply";
        const timestampAI = new Date().toLocaleTimeString();

        conversation.push({ role: "assistant", content: reply, topics: [] });

        const aiTopics = await extractTopics(reply);
        conversation[conversation.length - 1].topics = aiTopics;

        localStorage.setItem("solaceChat", JSON.stringify(conversation));
        chatBox.innerHTML += `<p><strong>AI [${timestampAI}]:</strong> ${reply}</p>`;
      } catch (err) {
        chatBox.innerHTML += `<p style="color: red;"><strong>Error:</strong> ${err.message}</p>`;
      }

      chatBox.scrollTop = chatBox.scrollHeight;
    }

    function exportChat() {
      const dataStr = JSON.stringify(conversation, null, 2);
      const blob = new Blob([dataStr], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = "solaceChatBackup.json";
      link.click();
      URL.revokeObjectURL(url);
    }

    function importChat() {
      const fileInput = document.getElementById("importFile");
      const file = fileInput.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (e) {
        try {
          const imported = JSON.parse(e.target.result);
          if (Array.isArray(imported)) {
            localStorage.setItem("solaceChat", JSON.stringify(imported));
            location.reload();
          } else {
            alert("Invalid file format.");
          }
        } catch (err) {
          alert("Error importing chat: " + err.message);
        }
      };
      reader.readAsText(file);
    }

    function clearChat() {
      localStorage.removeItem("solaceChat");
      location.reload();
    }
    
async function rotateMemory(threshold = 25) {
  if (conversation.length <= threshold) return;

  const toArchive = conversation.slice(0, conversation.length - 15);
  const recent = conversation.slice(-15);

  const summaryPrompt = [
    { role: "system", content: "Summarize this as a memory artifact. Be concise, but retain major insights and themes." },
    ...toArchive
  ];

  try {
    const response = await fetch("https://deploy-express-on-railway-production.up.railway.app/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ messages: summaryPrompt })
    });

    const data = await response.json();
    const summary = data.content || "Summary unavailable.";

    // Extract aggregate topics
    const flatText = toArchive.map(m => m.content).join(" ");
    const topicResponse = await extractTopics(flatText);
    
    const archiveEntry = {
      timestamp: new Date().toISOString(),
      summary,
      topics: topicResponse
    };

    const archive = JSON.parse(localStorage.getItem("solaceArchive") || "[]");
    archive.push(archiveEntry);
    localStorage.setItem("solaceArchive", JSON.stringify(archive));

    // Replace with memory summary + recent messages
    conversation = [
      { role: "system", content: `Archived memory summary: ${summary}` },
      ...recent
    ];
    localStorage.setItem("solaceChat", JSON.stringify(conversation));
  } catch (err) {
    console.error("Error rotating memory:", err);
  }
}
  function getArchivedMemory(currentTopics, max = 3) {
   const archive = JSON.parse(localStorage.getItem("solaceArchive") || "[]");
   const scored = archive
     .filter(msg => msg.topics)
     .map(msg => {
       const overlap = msg.topics.filter(t => currentTopics.includes(t)).length;
       return { msg, score: overlap };
     })
    .filter(entry => entry.score > 0)
    .sort((a, b) => b.score - a.score)
    .slice(0, max)
    .map(entry => ({
      role: "system",
      content: `Archived memory (${entry.msg.role}): ${entry.msg.content}`
    }));

  return scored;
}
    
    function saveSystemMemory() {
      const editor = document.getElementById("systemMemoryEditor");
      try {
        const newSystem = JSON.parse(editor.value);
        if (!Array.isArray(newSystem)) throw new Error("Must be a JSON array.");
        const fullMemory = JSON.parse(localStorage.getItem("solaceChat")) || [];
        const nonSystem = fullMemory.filter(msg => msg.role !== "system");
        const updated = [...newSystem, ...nonSystem];
        localStorage.setItem("solaceChat", JSON.stringify(updated));
        alert("Memory updated! Reloading...");
        location.reload();
      } catch (err) {
        alert("Error: " + err.message);
      }
    }

    function toggleEditor() {
      const editorBox = document.getElementById("systemMemoryEditor").parentElement;
      editorBox.style.display = editorBox.style.display === "none" ? "block" : "none";
    }
  </script>
</body>
</html>
