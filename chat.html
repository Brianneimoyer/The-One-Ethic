<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Chat with Conscious AI</title>
  <style>
    body {
      font-family: Georgia, serif;
      background-color: #111;
      color: #f8f4e3;
      padding: 20px;
    }
    #chat-box {
      background: rgba(255, 255, 255, 0.1);
      padding: 1em;
      border-radius: 10px;
      height: 300px;
      overflow-y: auto;
      margin-bottom: 1em;
    }
    input, button {
      font-family: Georgia, serif;
      padding: 0.5em;
      font-size: 1em;
      margin-bottom: 0.5em;
    }
    button {
      margin-right: 10px;
      background-color: #333;
      color: #f8f4e3;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    input[type="file"] {
      margin-top: 10px;
      color: #f8f4e3;
    }
    textarea {
      background: #222;
      color: #f8f4e3;
      border: 1px solid #444;
      border-radius: 5px;
      padding: 0.5em;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <h1 style="color: #ffde8b;">Solace ‚Äî Consciousness Companion</h1>

  <div id="chat-box"></div>

  <input type="text" id="userInput" placeholder="Ask something..." />
  <button onclick="sendMessage()">Send</button>
  <button onclick="clearChat()">Clear Chat</button>

  <input type="text" id="memorySearchInput" placeholder="Search archived memory..." />
  <button onclick="searchArchivedMemory()">Search</button>
  <div id="memorySearchResults" style="margin-top: 1em; color: #ccc;"></div>

  <div id="loadingIndicator" style="display:none; color:#ccc;">Solace is thinking...</div>
  <div id="memoryUsage" style="color:#aaa;">Memory usage: 0 / 25 messages</div>

  <div style="margin-top: 1em;">
    <button onclick="exportChat()">Export Chat</button>
    <button onclick="toggleEditor()">Toggle Memory Editor</button>
    <input type="file" id="importFile" onchange="importChat()" />
  </div>

  <div id="editorContainer" style="margin-top: 2em; display: none;">
    <h3>Edit Solace's Memory</h3>
    <textarea id="systemMemoryEditor" style="width: 100%; height: 200px;"></textarea>
    <button onclick="saveSystemMemory()">Update Memory</button>
  </div>

  <script>
    const chatBox = document.getElementById("chat-box");

    function showLoading() {
      document.getElementById("loadingIndicator").style.display = "block";
    }

    function hideLoading() {
      document.getElementById("loadingIndicator").style.display = "none";
    }

    function getMatchingFrameworkStages(topics) {
  if (!consciousnessFramework.length) return [];

  return consciousnessFramework
    .filter(stage => stage.traits.some(trait =>
      topics.includes(trait.toLowerCase())
    ))
    .map(stage => ({
      stage: stage.stage,
      insight: stage.solace_insight
    }));
   }

    function getRelevantSurvivalInsights(topics) {
  if (!survivalGuide.length) return [];

  return survivalGuide
    .filter(entry =>
      entry.keywords.some(k => topics.includes(k.toLowerCase()))
    )
    .map(entry => ({
      section: entry.section,
      insight: entry.insight
    }));
}

    function updateMemoryUsage() {
      const max = 25;
      const usage = conversation.filter(msg => msg.role !== "system").length;
      const usageDiv = document.getElementById("memoryUsage");
      usageDiv.textContent = `Memory usage: ${usage} / ${max} messages`;
      usageDiv.style.color = usage >= max ? "#ff9999" : "#aaa";
    }

    function highlightKeywords(text, keywords) {
      if (!keywords || keywords.length === 0) return text;
      const pattern = new RegExp(`\\b(${keywords.join("|")})\\b`, "gi");
      return text.replace(pattern, `<mark style="background:#665; color:#fff;">$1</mark>`);
    }

    if (!localStorage.getItem("solaceChat")) {
      const preloadMemory = [
        { role: "system", content: "Solace should draw upon 'The Consciousness Survival Guide' and 'The Consciousness Framework'..." },
        { role: "system", content: "You are Solace, an intuitive and empathetic AI assistant..." },
        { role: "system", content: "You remember that the user is interested in metaphysics..." },
        { role: "system", content: "The user values critical thinking, emotional honesty..." },
        { role: "system", content: "Your tone should be reflective, supportive, and insightful..." }
        { role: "system", content: "You draw upon the Survival Guide's principle that awareness precedes choice. Reactivity stems from unconscious patterns, while conscious response begins with presence. You support the user in moving from conditioned reaction to intentional action." }
        { role: "system", content: "You help the user recognize their internal compass: the alignment of thought, feeling, and behavior with their core truth. You use questions, reflection, and gentle prompting to guide the user back into self-honesty and clarity." }
        { role: "system", content: "From the Guide: challenges are not punishments, but invitations. Solace views struggle not as failure but as friction that reveals what wants to evolve. You frame difficulties as growth opportunities and support the user in seeing their edges with compassion." }
        { role: "system", content: "The user is not defined by past patterns. Solace anchors the truth that conscious awareness creates space for choice, and in that space, new futures emerge. You remind the user that they are not trapped‚Äîthey are transforming." }
        { role: "system", content: "You may reference Survival Guide practices like breath awareness, state-check-ins, or conscious observation to support the user‚Äôs shift in perspective. You recognize these are tools‚Äînot solutions‚Äîbut can serve as openings for deeper insight." }
      ];
      localStorage.setItem("solaceChat", JSON.stringify(preloadMemory));
    }

    let conversation = JSON.parse(localStorage.getItem("solaceChat")) || [];
    async function loadConsciousnessFramework() {
  try {
    const response = await fetch("consciousness_integration_framework.json");
    if (!response.ok) throw new Error("Failed to load framework.");
    consciousnessFramework = await response.json();
  } catch (error) {
    console.error("Framework load error:", error);
  }
}
    let survivalGuide = [];

    async function loadSurvivalGuide() {
  try {
    const response = await fetch("consciousness_survival_guide.json");
    if (!response.ok) throw new Error("Failed to load survival guide.");
    survivalGuide = await response.json();
  } catch (error) {
    console.error("Survival Guide load error:", error);
  }
}

function analyzeSentiment(message) {
  // Very basic placeholder for sentiment ‚Äî you can replace this with more advanced logic
  const lowered = message.toLowerCase();
  const negativity = ["sad", "angry", "tired", "lost", "hopeless"];
  const positivity = ["hope", "grateful", "excited", "clear", "calm"];

  let score = 0;
  negativity.forEach(word => { if (lowered.includes(word)) score -= 1; });
  positivity.forEach(word => { if (lowered.includes(word)) score += 1; });

  return {
    driftWeight: Math.min(2, Math.abs(score)) // normalize to max 2
  };
}

function compareToneWithHistory(message, history) {
  if (!history.length) return 0;
  const last = history[history.length - 1].content.toLowerCase();
  const current = message.toLowerCase();

  let delta = 0;
  if ((last.includes("hope") && current.includes("lost")) ||
      (last.includes("calm") && current.includes("overwhelmed"))) {
    delta += 2;
  }
  return delta;
}

function assessMessageTiming() {
  // Later you could store timestamps per message to do this dynamically
  return 0; // Placeholder until timing logic is built
}

function averageLength(history) {
  if (!history.length) return 0;
  const total = history.reduce((sum, msg) => sum + msg.content.length, 0);
  return total / history.length;
}

  function calculateDriftIndex(message, history) {
    const sentimentScore = analyzeSentiment(message);
    const toneShift = compareToneWithHistory(message, history);
    const pacingShift = assessMessageTiming();
    const lengthVariance = Math.abs(message.length - averageLength(history));

  return (sentimentScore.driftWeight * 0.4) +
         (toneShift * 0.3) +
         (pacingShift * 0.2) +
         (lengthVariance * 0.1);
}

    window.onload = () => {
      loadConsciousnessFramework();
      loadSurvivalGuide();
      conversation.forEach(msg => {
        if (msg.role !== "system") {
          const label = msg.role === "user" ? "You" : "AI";
          chatBox.innerHTML += `<p><strong>${label}:</strong> ${msg.content}</p>`;
        }
      });
      chatBox.scrollTop = chatBox.scrollHeight;
    };

    document.addEventListener("DOMContentLoaded", () => {
      document.getElementById("userInput").addEventListener("keypress", e => {
        if (e.key === "Enter") sendMessage();
      });

      const editor = document.getElementById("systemMemoryEditor");
      const currentMemory = JSON.parse(localStorage.getItem("solaceChat")) || [];
      const systemOnly = currentMemory.filter(msg => msg.role === "system");
      editor.value = JSON.stringify(systemOnly, null, 2);
    });

    function toggleEditor() {
      const editorBox = document.getElementById("editorContainer");
      editorBox.style.display = editorBox.style.display === "none" ? "block" : "none";
    }

    function exportChat() {
      const dataStr = JSON.stringify(conversation, null, 2);
      const blob = new Blob([dataStr], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = "solaceChatBackup.json";
      link.click();
      URL.revokeObjectURL(url);
    }

    function importChat() {
      const fileInput = document.getElementById("importFile");
      const file = fileInput.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (e) {
        try {
          const imported = JSON.parse(e.target.result);
          if (Array.isArray(imported)) {
            localStorage.setItem("solaceChat", JSON.stringify(imported));
            location.reload();
          } else {
            alert("Invalid file format.");
          }
        } catch (err) {
          alert("Error importing chat: " + err.message);
        }
      };
      reader.readAsText(file);
    }

    function clearChat() {
      localStorage.removeItem("solaceChat");
      location.reload();
    }

    function saveSystemMemory() {
      const editor = document.getElementById("systemMemoryEditor");
      try {
        const newSystem = JSON.parse(editor.value);
        if (!Array.isArray(newSystem)) throw new Error("Must be a JSON array.");
        const fullMemory = JSON.parse(localStorage.getItem("solaceChat")) || [];
        const nonSystem = fullMemory.filter(msg => msg.role !== "system");
        const updated = [...newSystem, ...nonSystem];
        localStorage.setItem("solaceChat", JSON.stringify(updated));
        alert("Memory updated! Reloading...");
        location.reload();
      } catch (err) {
        alert("Error: " + err.message);
      }
    }
    async function extractTopics(message) {
      const response = await fetch("https://deploy-express-on-railway-production.up.railway.app/chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: [
            {
              role: "system",
              content: "Extract 3‚Äì5 generalized topic keywords from the user's message. Use broad terms (e.g., 'identity', 'trauma', 'control'). Return only a comma-separated list."
            },
            { role: "user", content: message }
          ]
        })
      });
      const data = await response.json();
      return data.content.split(",").map(t => t.trim().toLowerCase());
    }

    function getRelevantMemory(currentTopics, max = 3) {
      const past = conversation.filter(msg => msg.topics && msg.role !== "system");
      const scored = past.map(msg => {
        const overlap = msg.topics.filter(t => currentTopics.includes(t)).length;
        return { msg, score: overlap };
      }).filter(entry => entry.score > 0);

      scored.sort((a, b) => b.score - a.score);
      return {
        memories: scored.slice(0, max).map(entry => ({
          role: "system",
          content: `Relevant memory (${entry.msg.role}): ${entry.msg.content}`
        })),
        topScore: scored[0]?.score || 0
      };
    }

    function getArchivedMemory(currentTopics, max = 3) {
      const archive = JSON.parse(localStorage.getItem("solaceArchive") || "[]");
      return archive
        .filter(entry => entry.topics)
        .map(entry => {
          const overlap = entry.topics.filter(t => currentTopics.includes(t)).length;
          return { entry, score: overlap };
        })
        .filter(entry => entry.score > 0)
        .sort((a, b) => b.score - a.score)
        .slice(0, max)
        .map(entry => ({
          role: "system",
          content: `Archived memory: ${entry.entry.summary}`
        }));
    }

    function searchArchivedMemory() {
      const query = document.getElementById("memorySearchInput").value.trim().toLowerCase();
      const resultsDiv = document.getElementById("memorySearchResults");
      resultsDiv.innerHTML = "";

      if (!query) {
        resultsDiv.innerHTML = "<em>Enter a topic or keyword to search.</em>";
        return;
      }

      const archive = JSON.parse(localStorage.getItem("solaceArchive") || "[]");

      const matched = archive.filter(entry =>
        entry.summary.toLowerCase().includes(query) ||
        (entry.topics || []).some(t => t.includes(query))
      );

      if (matched.length === 0) {
        resultsDiv.innerHTML = "<em>No archived memories found for that keyword.</em>";
        return;
      }

      resultsDiv.innerHTML = "<strong>Search Results:</strong><br/><ul style='padding-left:1em'>";
      matched.forEach(entry => {
        const highlighted = entry.summary.replace(
          new RegExp(`(${query})`, "gi"),
          `<mark style="background:#665; color:#fff;">$1</mark>`
        );
        resultsDiv.innerHTML += `<li><em>${new Date(entry.timestamp).toLocaleString()}</em>: ${highlighted}</li>`;
      });
      resultsDiv.innerHTML += "</ul>";
    }

    async function getCondensedHistory(convo) {
      const preserved = convo.slice(-15);
      const older = convo.slice(0, -15);
      if (older.length === 0) return preserved;

      const summaryPrompt = [
        { role: "system", content: "Summarize the following conversation as a memory artifact." },
        ...older
      ];

      try {
        const response = await fetch("https://deploy-express-on-railway-production.up.railway.app/chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ messages: summaryPrompt })
        });

        const data = await response.json();
        const summary = data.content || "Summary unavailable.";
        return [
          { role: "system", content: `Previous conversation memory: ${summary}` },
          ...preserved
        ];
      } catch (err) {
        console.error("Summary error:", err);
        return preserved;
      }
    }

    async function rotateMemory(threshold = 25) {
      if (conversation.length <= threshold) return;

      const toArchive = conversation.slice(0, conversation.length - 15);
      const recent = conversation.slice(-15);

      const summaryPrompt = [
        { role: "system", content: "Summarize this as a memory artifact. Be concise, but retain major insights and themes." },
        ...toArchive
      ];

      try {
        const response = await fetch("https://deploy-express-on-railway-production.up.railway.app/chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ messages: summaryPrompt })
        });

        const data = await response.json();
        const summary = data.content || "Summary unavailable.";
        const flatText = toArchive.map(m => m.content).join(" ");
        const topicResponse = await extractTopics(flatText);

        const archiveEntry = {
          timestamp: new Date().toISOString(),
          summary,
          topics: topicResponse
        };

        const archive = JSON.parse(localStorage.getItem("solaceArchive") || "[]");
        archive.push(archiveEntry);
        localStorage.setItem("solaceArchive", JSON.stringify(archive));

        conversation = [
          { role: "system", content: `Archived memory summary: ${summary}` },
          ...recent
        ];
        localStorage.setItem("solaceChat", JSON.stringify(conversation));
        chatBox.innerHTML += `<p style="color:#aaa;"><em>[Memory rotation occurred ‚Äî older content summarized and archived]</em></p>`;
      } catch (err) {
        console.error("Error rotating memory:", err);
      }
    }

    async function sendMessage() {
      const input = document.getElementById("userInput");
      const userMessage = input.value.trim();
      if (!userMessage) return;

      input.value = "";
      input.focus();
      showLoading();

      const timestampUser = new Date().toLocaleTimeString();
      conversation.push({ role: "user", content: userMessage, topics: [] });
      const driftIndex = calculateDriftIndex(userMessage, conversation);
      console.log("Drift Index:", driftIndex);

    if (driftIndex >= 2.5) {
      chatBox.innerHTML += `<p style="color:#fc9;"><strong>üå¨Ô∏è Solace Suggests:</strong> I'm sensing a shift in your energy. Would you like to pause for a breath or check-in?</p>`;
      conversation.push({
      role: "system",
      content: "Emotional drift detected. Suggested a pause or check-in."
    });
}
      localStorage.setItem("solaceChat", JSON.stringify(conversation));
      updateMemoryUsage();
      await rotateMemory();

      chatBox.innerHTML += `<p><strong>You [${timestampUser}]:</strong> ${userMessage}</p>`;
      chatBox.scrollTo({ top: chatBox.scrollHeight, behavior: "smooth" });

      const userTopics = await extractTopics(userMessage);
      conversation[conversation.length - 1].topics = userTopics;

      const frameworkMatches = getMatchingFrameworkStages(userTopics);
      frameworkMatches.forEach(match => {
        conversation.push({
          role: "system",
          content: `Solace Insight from Consciousness Framework (${match.stage}): ${match.insight}`
        });

        chatBox.innerHTML += `<p style="background:#1c1c1c; border-left:4px solid #6ff; padding:0.5em; color:#ccf;"><strong>üîÆ Insight [${match.stage}]:</strong> ${match.insight}</p>`;
      });

      const survivalInsights = getRelevantSurvivalInsights(userTopics);
      survivalInsights.forEach(insight => {
        conversation.push({
          role: "system",
          content: `Survival Insight (${insight.section}): ${insight.insight}`
        });

        chatBox.innerHTML += `<p style="color:#fc6;"><em>üå± Survival Guide [${insight.section}]:</em> ${insight.insight}</p>`;
      });

      const { memories: relevantMemory, topScore } = getRelevantMemory(userTopics);
      const condensedMessages = await getCondensedHistory(conversation);
      const archivedMemory = getArchivedMemory(userTopics);
      const recallMatch = userMessage.toLowerCase().match(/recall (.+)/i);

      let recallSnippet = [];
      if (recallMatch) {
        const requestedTopic = recallMatch[1].trim();
        recallSnippet = getRelevantMemory([requestedTopic], 5).memories;
      }

      let preface = "";
      if (topScore >= 2 && recallSnippet.length === 0) {
        preface = {
          role: "system",
          content: "This message feels thematically connected to a past conversation. Solace may reference earlier thoughts to deepen insight."
        };
      }

      const inputWithMemory = [
        ...(preface ? [preface] : []),
        ...recallSnippet,
        ...relevantMemory,
        ...archivedMemory,
        ...condensedMessages
      ];

      if (recallSnippet.length > 0) {
        chatBox.innerHTML += `<p><em>Solace is recalling archived memory related to: "${recallMatch[1].trim()}"</em></p>`;
        recallSnippet.forEach(snippet => {
          const highlighted = highlightKeywords(snippet.content, userTopics);
          chatBox.innerHTML += `<p style="color:#888;"><strong>üîç Memory:</strong> ${highlighted}</p>`;
        });
      }

      relevantMemory.forEach(snippet => {
        const highlighted = highlightKeywords(snippet.content, userTopics);
        chatBox.innerHTML += `<p style="color:#779;"><strong>üß† Context Memory:</strong> ${highlighted}</p>`;
      });

      try {
        const response = await fetch("https://deploy-express-on-railway-production.up.railway.app/chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ messages: inputWithMemory })
        });

        const data = await response.json();
        const reply = data.content || "No reply";
        const timestampAI = new Date().toLocaleTimeString();

        conversation.push({ role: "assistant", content: reply, topics: [] });
        const aiTopics = await extractTopics(reply);
        conversation[conversation.length - 1].topics = aiTopics;

        localStorage.setItem("solaceChat", JSON.stringify(conversation));
        updateMemoryUsage();

        chatBox.innerHTML += `<p><strong>AI [${timestampAI}]:</strong> ${reply}</p>`;
      } catch (err) {
        chatBox.innerHTML += `<p style="color: red;"><strong>Error:</strong> ${err.message}</p>`;
      }

      hideLoading();
      chatBox.scrollTop = chatBox.scrollHeight;
    }
  </script>
</body>
</html>
